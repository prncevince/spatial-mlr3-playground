---
title: A Spatial Statistics Playground w/ mlr3 
output:
  html_document:
    anchor_sections: true
    code_folding: "hide"
    css: [assets/style.css]
    df_print: "default"
    includes:
      before_body: assets/style.html
    lib_dir: docs/libs
    math_method:
      engine: katex
    self_contained: FALSE
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
library(knitr)
options(digits.secs = 3)
options(width = 10000) # output code width for default print method
opts_chunk$set(echo = TRUE)
opts_chunk$set(results = 'hold')
opts_chunk$set(message = FALSE)

output <- "docs"
fig.path <- paste0(output, '/assets/img/')

if (!dir.exists(fig.path)) dir.create(fig.path, recursive = T)
opts_chunk$set(fig.path = fig.path)

if (!dir.exists(paste0(output, '/assets/'))) dir.create(paste0(output, '/assets/', recursive = T))
system(sprintf("cp -u assets/style.css %s/assets/", output))

knitr::knit_hooks$set(link = function(before, options) {
  if (before) {
    paste0(
      '<div id="_', gsub("\\.", "", options$label), '_" class="section level5 hasAnchor">',
      '<h5 class="hasAnchor">', options$label,
      '<a href="#_', gsub("\\.", "", options$label),
      '_" class="anchor-section" aria-label="Anchor link to header"></a>',
      '</h5>'
    )
  } else {
    '</div>'
  }
})
knitr::opts_chunk$set(link = TRUE)
```

## Setup

```{r packages, warning=FALSE}
# from pca-mlr3-pipelines
library(mlr3verse)
library(data.table)
library(future)
library(igraph)
library(ggfortify)
library(scattermore)
library(R6)
library(rlang)
# from Statistical Learning | Geocomputation with R
library(lgr)
library(sf)
library(terra)
library(progressr)
library(mlr3spatiotempcv)
library(spDataLarge)
library(tmap)
library(tmaptools)
library(raster)
library(pROC)
```

```{r mlr3verse_info}
mlr3verse_info()
```

```{r packages-extras, eval=FALSE}
library(mlr3extralearners)
```

```{r multicore}
plan(multicore)
```

## Resources

- [12 Statistical learning | Geocomputing with R](https://geocompr.robinlovelace.net/spatial-cv.html)
    - https://github.com/Robinlovelace/geocompr/blob/main/12-spatial-cv.Rmd
- [8.3 Spatiotemporal Analysis | mlr3 Book](https://mlr3book.mlr-org.com/special-tasks.html#spatiotemporal)
- [Handling of Spatial Data](https://mlr.mlr-org.com/articles/tutorial/handling_of_spatial_data.html)
- [Chapter 16 Spatial Regression | Spatial Data Science](https://keen-swartz-3146c4.netlify.app/spatglmm.html)

## Landslide Susceptibility

### Data

```{r data}
data("lsl", "study_mask", package = "spDataLarge")
lsl <- as.data.table(lsl)
ta <- terra::rast(system.file("raster/ta.tif", package = "spDataLarge"))
```

```{r map-landslides, error=0}
lsl_sf <- st_as_sf(lsl, coords = c("x", "y"), crs = "EPSG:32717")

# generates errors
hs <- terra::shade(
  slope = ta$slope * pi / 180,
  terra::terrain(ta$elev, v = "aspect", unit = "radians")
)
# so far tmaptools does not support terra objects
bbx <- tmaptools::bb(
  raster::raster(hs), xlim = c(-0.0001, 1),
  ylim = c(-0.0001, 1), relative = TRUE
)

map <- tm_shape(hs, bbox = bbx) +
  tm_grid(
    col = "black", n.x = 1, n.y = 1, labels.inside.frame = FALSE,
    labels.rot = c(0, 90), lines = FALSE
  ) +
  tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) +
  tm_shape(ta$elev) +
  tm_raster(alpha = 0.5, palette = terrain.colors(10), legend.show = FALSE) +
  tm_shape(lsl_sf) +
  tm_bubbles(
    "lslpts", size = 0.2, palette = "-RdYlBu", title.col = "Landslide: "
  ) +
  tm_layout(inner.margins = 0) +
  tm_legend(bg.color = "white")
```

```{r map-landslides-fig, echo=FALSE}
map
```

```{r lsl}
print(lsl)
```

### GLM Classif - Spatial Bias

```{r glm-fit-pred}
fit <- glm(
  lslpts ~ slope + cplan + cprof + elev + log10_carea,
  family = binomial(),
  data = lsl
)

pred <- terra::predict(ta, model = fit, type = "response")
```

```{r map-landslides-glm-bias-pred, error=0}
# throws error
sv_study_mask <- terra::vect(study_mask)

map <- tm_shape(hs, bbox = bbx) +
  tm_grid(
    col = "black", n.x = 1, n.y = 1, labels.inside.frame = FALSE,
    labels.rot = c(0, 90), lines = FALSE
  ) +
  tm_raster(palette = "white", legend.show = FALSE) +
  # hillshade
  tm_shape(terra::mask(hs, sv_study_mask), bbox = bbx) +
  tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) +
  # prediction raster
  tm_shape(terra::mask(pred, sv_study_mask)) +
  tm_raster(
    alpha = 0.5, palette = "Reds", n = 6, legend.show = TRUE, title = "Susceptibility"
  ) +
  tm_layout(
    legend.position = c("left", "bottom"), legend.title.size = 0.9, inner.margins = 0
  )
```

```{r map-landslides-glm-bias-pred-fig, echo=FALSE}
map
```

### Spatial CV 

Here we introduce spatial cross validation to combat spatial bias. 

#### mlr3 Pipeline 

To perform our Spatial CV, we'll construct an mlr3 pipeline.

##### Task 

Note, both `TaskClassifST$new` & `as_task_classif_st` can accept `sf` objects, e.g. our `lsl_sf` object. When this is the case, spatial metadata can be extracted and used for input arguments to the task (e.g. `coordinate_names` & `crs` in the `extra_args` list).

However, apparently the task converts the `sf` object into a `data.table` object, which we know could become memory intensive when handling large data.

By default, all variables *other* than the `target` parameter & the `coordinate_names` within the `backend`/`x` object are used as predictor variables. By default `coords_as_features` is set to `FALSE`, which instructs the task to not use `coordinate_names` as predictors. Set this to `TRUE` to use them as predictors.

```{r task_new}
task_new <- mlr3spatiotempcv::TaskClassifST$new(
  id = "lsl",
  backend = mlr3::as_data_backend(lsl), 
  target = "lslpts", 
  positive = "TRUE",
  extra_args = list(
    coordinate_names = c("x", "y"),
    coords_as_features = FALSE,
    crs = "EPSG:32717"
  )
)

task_new
```

```{r task}
task <- as_task_classif_st(
  x = lsl,
  target = "lslpts",
  positive = "TRUE",
  coordinate_names = c("x", "y"),
  coords_as_features = FALSE,
  crs = "EPSG:32717"
)

task
```

Creating the tasks via the above methods seem to make them identical, but that's not ***strictly*** the case. 

```{r}
identical(task_new, task)
```

```{r plt_duo}
mlr3viz::autoplot(task, type = "duo")
```


```{r plot_pairs}
mlr3viz::autoplot(task, type = "pairs")
```

##### Learner

We'll use a logistic regression learner for this task since the response variable of `lsl$lslpts` is binary. 

```{r}
as.data.table(mlr_learners) %>% `[`(key == "classif.log_reg")
```

##### Graph

##### Graph Learner

##### Tuning / Training

This step is where our Spatial Cross-Validation actually happens. 

##### Prediction 
