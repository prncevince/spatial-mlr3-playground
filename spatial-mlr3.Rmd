---
title: A Spatial Statistics Playground w/ mlr3 
output:
  html_document:
    anchor_sections: true
    code_folding: "hide"
    css: [assets/style.css]
    df_print: "default"
    includes:
      before_body: assets/style.html
    lib_dir: docs/libs
    math_method:
      engine: katex
    self_contained: FALSE
    toc: true
    toc_depth: 6
    toc_float:
      collapsed: false
---

```{r setup, include=FALSE}
library(knitr)
options(digits.secs = 3)
options(width = 10000) # output code width for default print method
opts_chunk$set(echo = TRUE)
opts_chunk$set(results = 'hold')
opts_chunk$set(message = FALSE)

output <- "docs"
fig.path <- paste0(output, '/assets/img/')

if (!dir.exists(fig.path)) dir.create(fig.path, recursive = T)
opts_chunk$set(fig.path = fig.path)

if (!dir.exists(paste0(output, '/assets/'))) dir.create(paste0(output, '/assets/', recursive = T))
file.copy("assets/style.css", sprintf("%s/assets/", output), overwrite = T, copy.date = TRUE)

knitr::knit_hooks$set(link = function(before, options) {
  if (! grepl("^unnamed-chunk-[0-9]*$", options$label)) {
    if (before) {
      h <- 6
      paste0(
        '<div id="_', gsub("\\.", "", options$label), '_" class="section level', h, ' hasAnchor">',
        '<h', h, ' class="hasAnchor">', options$label,
        '<a href="#_', gsub("\\.", "", options$label),
        '_" class="anchor-section" aria-label="Anchor link to header"></a>',
        '</h', h, '>'
      )
    } else {
      '</div>'
    }
  }
})
knitr::opts_chunk$set(link = TRUE)
```

## Setup

```{r packages, warning=FALSE}
# from pca-mlr3-pipelines
library(mlr3verse)
library(data.table)
library(future)
library(igraph)
library(ggfortify)
library(scattermore)
library(R6)
library(rlang)
# from Statistical Learning | Geocomputation with R
library(lgr)
library(sf)
library(terra)
library(progressr)
library(mlr3spatiotempcv)
library(spDataLarge)
library(tmap)
library(tmaptools)
library(raster)
library(pROC)
library(tictoc)
library(ggplot2)
```

```{r mlr3verse_info}
mlr3verse_info()
```

```{r packages-extras, eval=FALSE}
library(mlr3extralearners)
```

## Resources

- [Geocomputing with R](https://geocompr.robinlovelace.net)
    - [Chapter 12 Statistical learning](https://geocompr.robinlovelace.net/spatial-cv.html)
        - https://github.com/Robinlovelace/geocompr/blob/main/12-spatial-cv.Rmd
        - https://github.com/Robinlovelace/geocompr/blob/main/code/12-cv.R
- [Chapter 8.3 Spatiotemporal Analysis | mlr3 Book](https://mlr3book.mlr-org.com/special-tasks.html#spatiotemporal)
- [Handling of Spatial Data | mlr v2 articles](https://mlr.mlr-org.com/articles/tutorial/handling_of_spatial_data.html)
- [Spatial Data Science](https://keen-swartz-3146c4.netlify.app)
    - [Chapter 12 Spatial Interpolation](https://keen-swartz-3146c4.netlify.app/interpolation.html)
    - [Chapter 16 Spatial Regression](https://keen-swartz-3146c4.netlify.app/spatglmm.html)

## Landslide Susceptibility

### Data

```{r data}
data("lsl", "study_mask", package = "spDataLarge")
lsl <- as.data.table(lsl)
ta <- terra::rast(system.file("raster/ta.tif", package = "spDataLarge"))
```

```{r map-landslides, error=0}
lsl_sf <- st_as_sf(lsl, coords = c("x", "y"), crs = "EPSG:32717")

# generates errors
slope1 <- ta$slope * pi / 180
aspect <- terra::terrain(ta$elev, v = "aspect", unit = "radians")
hs <- terra::shade(slope = slope1, aspect = aspect)
# so far tmaptools does not support terra objects
bbx <- tmaptools::bb(
  raster::raster(hs), xlim = c(-0.0001, 1),
  ylim = c(-0.0001, 1), relative = TRUE
)

map <- tm_shape(hs, bbox = bbx) +
  tm_grid(
    col = "black", n.x = 1, n.y = 1, labels.inside.frame = FALSE,
    labels.rot = c(0, 90), lines = FALSE
  ) +
  tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) +
  tm_shape(ta$elev) +
  tm_raster(alpha = 0.5, palette = terrain.colors(10), legend.show = FALSE) +
  tm_shape(lsl_sf) +
  tm_bubbles(
    "lslpts", size = 0.2, palette = "-RdYlBu", title.col = "Landslide: "
  ) +
  tm_layout(inner.margins = 0) +
  tm_legend(bg.color = "white")
```

```{r map-landslides-fig, echo=FALSE}
map
```

```{r lsl}
print(lsl)
```

### GLM Classif - Spatial Bias

```{r glm-fit-pred}
fit <- glm(
  lslpts ~ slope + cplan + cprof + elev + log10_carea,
  family = binomial(),
  data = lsl
)

pred <- terra::predict(ta, model = fit, type = "response")
```

```{r map-landslides-glm-bias-pred, error=0}
# throws error
sv_study_mask <- terra::vect(study_mask)

map <- tm_shape(hs, bbox = bbx) +
  tm_grid(
    col = "black", n.x = 1, n.y = 1, labels.inside.frame = FALSE,
    labels.rot = c(0, 90), lines = FALSE
  ) +
  tm_raster(palette = "white", legend.show = FALSE) +
  # hillshade
  tm_shape(terra::mask(hs, sv_study_mask), bbox = bbx) +
  tm_raster(palette = gray(0:100 / 100), n = 100, legend.show = FALSE) +
  # prediction raster
  tm_shape(terra::mask(pred, sv_study_mask)) +
  tm_raster(
    alpha = 0.5, palette = "Reds", n = 6, legend.show = TRUE, title = "Susceptibility"
  ) +
  tm_layout(
    legend.position = c("left", "bottom"), legend.title.size = 0.9, inner.margins = 0
  )
```

```{r map-landslides-glm-bias-pred-fig, echo=FALSE}
map
```

```{r}
pROC::auc(pROC::roc(lsl$lslpts, fitted(fit)))
```


### Spatial CV using mlr3

Here we introduce spatial cross validation to combat spatial autocorrelation and bias. We'll use the mlr3 framework to build our model.

Specifically, we'll run 4 models using an mlr3 'design'. A design is a table of scenarios (models to be evaluated) of unique combinations of [`Task`](https://mlr3.mlr-org.com/reference/Task.html), [`Learner`](https://mlr3.mlr-org.com/reference/Learner.html), and [`Resampling`](https://mlr3.mlr-org.com/reference/Resampling.html) objects.

We create the design using `benchmar_grid` and can run the design object using `benchmark`. 

We will parallelize the execution of our models as much as possible. This depends on the number of cores that are available on our machine and by how we instruct `future`s to be resolved by specifying the [future topology](https://future.futureverse.org/articles/future-3-topologies.html) via `future::plan`. An optimal approach can also depend on types of resampling methods used by each of our models (e.g. nested resampling can be executing in parallel in the inner resampling loop), as well as the dimensions of our design. 

#### Task 

Note, both `TaskClassifST$new` & `as_task_classif_st` can accept `sf` objects, e.g. our `lsl_sf` object. When this is the case, spatial metadata can be extracted and used for input arguments to the task (e.g. `coordinate_names` & `crs` in the `extra_args` list).

However, apparently the task converts the `sf` object into a `data.table` object, which we know could become memory intensive when handling large data.

By default, all variables *other* than the `target` parameter & the `coordinate_names` within the `backend`/`x` object are used as predictor variables. By default `coords_as_features` is set to `FALSE`, which instructs the task to not use `coordinate_names` as predictors. Set this to `TRUE` to use them as predictors.

```{r task_new}
task_new <- mlr3spatiotempcv::TaskClassifST$new(
  id = "lsl",
  backend = mlr3::as_data_backend(lsl), 
  target = "lslpts", 
  positive = "TRUE",
  extra_args = list(
    coordinate_names = c("x", "y"),
    coords_as_features = FALSE,
    crs = "EPSG:32717"
  )
)

task_new
```

```{r task}
task <- as_task_classif_st(
  x = lsl,
  target = "lslpts",
  positive = "TRUE",
  coordinate_names = c("x", "y"),
  coords_as_features = FALSE,
  crs = "EPSG:32717"
)

task
```

Creating the tasks via the above methods seem to make them identical, but that's not ***strictly*** the case. 

```{r}
identical(task_new, task)
```

```{r plt_duo}
mlr3viz::autoplot(task, type = "duo")
```


```{r plot_pairs}
mlr3viz::autoplot(task, type = "pairs")
```

#### Learner

We'll use a logistic regression learner for this task since the response variable of `lsl$lslpts` is binary. 

```{r}
as.data.table(mlr_learners) %>% `[`(key == "classif.log_reg")
```

```{r}
learner = lrn("classif.log_reg", predict_type = "prob")
```

#### Resampling

```{r}
resamplings = list(
  rsmp("repeated_spcv_coords", folds = 5, repeats = 100),
  rsmp("repeated_cv", folds = 5, repeats = 100)
)
```

#### Design & Benchmark Grid

```{r}
design = benchmark_grid(
  tasks = task,
  learners = learner,
  resamplings = resamplings
)

design
```

#### Execution - Training

Set seed for reproducibility

```{r}
set.seed(1)

plan(multisession)
```

```{r}
lgr::get_logger("mlr3")$set_threshold("warn")

tic()
progressr::with_progress(
  bmr <- benchmark(
    design = design,
    store_models = TRUE,
    store_backends = FALSE,
    encapsulate = "evaluate"
  )
)
toc()
```

```{r}
p_auroc <- autoplot(bmr, measure = msr("classif.auc"))
p_auroc$labels$y = "AUROC"
p_auroc$layers[[1]]$aes_params$fill = c("lightblue2", "mistyrose2")

p_auroc + scale_x_discrete(labels=c("spatial CV", "conventional CV"))
```


```{r}
autoplot(bmr) + scale_x_discrete(labels=c("spatial CV", "conventional CV"))
```

#### Prediction 

```{r}
```

